// This file was generated by ODB, object-relational mapping (ORM)
// compiler for C++.
//

#ifndef MHJDATABASE_ODB_HXX
#define MHJDATABASE_ODB_HXX
#ifdef SQLITE
#include <odb/version.hxx>

#if (ODB_VERSION != 20400UL)
#error ODB runtime version mismatch
#endif

#include <odb/pre.hxx>

#include "MHJDatabase.hxx"

#include <memory>
#include <cstddef>

#include <odb/core.hxx>
#include <odb/traits.hxx>
#include <odb/callback.hxx>
#include <odb/wrapper-traits.hxx>
#include <odb/pointer-traits.hxx>
#include <odb/tr1/wrapper-traits.hxx>
#include <odb/tr1/pointer-traits.hxx>
#include <odb/container-traits.hxx>
#include <odb/no-op-cache-traits.hxx>
#include <odb/result.hxx>
#include <odb/simple-object-result.hxx>
#include <odb/view-image.hxx>
#include <odb/view-result.hxx>

#include <odb/details/unused.hxx>
#include <odb/details/shared-ptr.hxx>

namespace odb
{
  // MHJDeviceBase
  //
  template <>
  struct class_traits< ::MHJDeviceBase >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::MHJDeviceBase >
  {
    public:
    typedef ::MHJDeviceBase object_type;
    typedef ::std::tr1::shared_ptr< ::MHJDeviceBase > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    no_op_pointer_cache_traits<pointer_type>
    pointer_cache_traits;

    typedef
    no_op_reference_cache_traits<object_type>
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  // MHJDeviceChild
  //
  template <>
  struct class_traits< ::MHJDeviceChild >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::MHJDeviceChild >
  {
    public:
    typedef ::MHJDeviceChild object_type;
    typedef ::std::tr1::shared_ptr< ::MHJDeviceChild > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    no_op_pointer_cache_traits<pointer_type>
    pointer_cache_traits;

    typedef
    no_op_reference_cache_traits<object_type>
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  // MHJDeviceVirtualDefine
  //
  template <>
  struct class_traits< ::MHJDeviceVirtualDefine >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::MHJDeviceVirtualDefine >
  {
    public:
    typedef ::MHJDeviceVirtualDefine object_type;
    typedef ::std::tr1::shared_ptr< ::MHJDeviceVirtualDefine > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    no_op_pointer_cache_traits<pointer_type>
    pointer_cache_traits;

    typedef
    no_op_reference_cache_traits<object_type>
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  // MHJDeviceActivation
  //
  template <>
  struct class_traits< ::MHJDeviceActivation >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::MHJDeviceActivation >
  {
    public:
    typedef ::MHJDeviceActivation object_type;
    typedef ::std::tr1::shared_ptr< ::MHJDeviceActivation > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    no_op_pointer_cache_traits<pointer_type>
    pointer_cache_traits;

    typedef
    no_op_reference_cache_traits<object_type>
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  // MHJDeviceAuthorize
  //
  template <>
  struct class_traits< ::MHJDeviceAuthorize >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::MHJDeviceAuthorize >
  {
    public:
    typedef ::MHJDeviceAuthorize object_type;
    typedef ::std::tr1::shared_ptr< ::MHJDeviceAuthorize > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    no_op_pointer_cache_traits<pointer_type>
    pointer_cache_traits;

    typedef
    no_op_reference_cache_traits<object_type>
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  // MHJUserEntity
  //
  template <>
  struct class_traits< ::MHJUserEntity >
  {
    static const class_kind kind = class_view;
  };

  template <>
  class access::view_traits< ::MHJUserEntity >
  {
    public:
    typedef ::MHJUserEntity view_type;
    typedef ::std::tr1::shared_ptr< ::MHJUserEntity > pointer_type;

    static void
    callback (database&, view_type&, callback_event);
  };

  // MHJAdminEntity
  //
  template <>
  struct class_traits< ::MHJAdminEntity >
  {
    static const class_kind kind = class_view;
  };

  template <>
  class access::view_traits< ::MHJAdminEntity >
  {
    public:
    typedef ::MHJAdminEntity view_type;
    typedef ::std::tr1::shared_ptr< ::MHJAdminEntity > pointer_type;

    static void
    callback (database&, view_type&, callback_event);
  };
}

#include <odb/details/buffer.hxx>

#include <odb/mysql/version.hxx>
#include <odb/mysql/forward.hxx>
#include <odb/mysql/binding.hxx>
#include <odb/mysql/mysql-types.hxx>
#include <odb/mysql/query.hxx>

namespace odb
{
  // MHJDeviceBase
  //
  template <typename A>
  struct query_columns< ::MHJDeviceBase, id_mysql, A >
  {
    // id
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long unsigned int,
        mysql::id_ulonglong >::query_type,
      mysql::id_ulonglong >
    id_type_;

    static const id_type_ id;

    // deviceID
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        unsigned int,
        mysql::id_long >::query_type,
      mysql::id_long >
    deviceID_type_;

    static const deviceID_type_ deviceID;

    // idsecurity
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::uint16_t,
        mysql::id_long >::query_type,
      mysql::id_long >
    idsecurity_type_;

    static const idsecurity_type_ idsecurity;

    // deviceType
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::uint16_t,
        mysql::id_long >::query_type,
      mysql::id_long >
    deviceType_type_;

    static const deviceType_type_ deviceType;

    // virtualKeyCount
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::uint16_t,
        mysql::id_long >::query_type,
      mysql::id_long >
    virtualKeyCount_type_;

    static const virtualKeyCount_type_ virtualKeyCount;

    // virtualKeyDefine
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        char[16],
        mysql::id_string >::query_type,
      mysql::id_string >
    virtualKeyDefine_type_;

    static const virtualKeyDefine_type_ virtualKeyDefine;

    // switchKeyfCount
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::uint16_t,
        mysql::id_long >::query_type,
      mysql::id_long >
    switchKeyfCount_type_;

    static const switchKeyfCount_type_ switchKeyfCount;

    // security
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        char[32],
        mysql::id_string >::query_type,
      mysql::id_string >
    security_type_;

    static const security_type_ security;

    // createDate
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::boost::posix_time::ptime,
        mysql::id_datetime >::query_type,
      mysql::id_datetime >
    createDate_type_;

    static const createDate_type_ createDate;

    // createUser
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    createUser_type_;

    static const createUser_type_ createUser;

    // createVerification
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        bool,
        mysql::id_tiny >::query_type,
      mysql::id_tiny >
    createVerification_type_;

    static const createVerification_type_ createVerification;

    // productionDate
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::boost::posix_time::ptime,
        mysql::id_datetime >::query_type,
      mysql::id_datetime >
    productionDate_type_;

    static const productionDate_type_ productionDate;

    // productionUser
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    productionUser_type_;

    static const productionUser_type_ productionUser;

    // activationDate
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::boost::posix_time::ptime,
        mysql::id_datetime >::query_type,
      mysql::id_datetime >
    activationDate_type_;

    static const activationDate_type_ activationDate;

    // deviceFlag
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        int,
        mysql::id_long >::query_type,
      mysql::id_long >
    deviceFlag_type_;

    static const deviceFlag_type_ deviceFlag;
  };

  template <typename A>
  const typename query_columns< ::MHJDeviceBase, id_mysql, A >::id_type_
  query_columns< ::MHJDeviceBase, id_mysql, A >::
  id (A::table_name, "`id`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceBase, id_mysql, A >::deviceID_type_
  query_columns< ::MHJDeviceBase, id_mysql, A >::
  deviceID (A::table_name, "`deviceID`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceBase, id_mysql, A >::idsecurity_type_
  query_columns< ::MHJDeviceBase, id_mysql, A >::
  idsecurity (A::table_name, "`idsecurity`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceBase, id_mysql, A >::deviceType_type_
  query_columns< ::MHJDeviceBase, id_mysql, A >::
  deviceType (A::table_name, "`deviceType`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceBase, id_mysql, A >::virtualKeyCount_type_
  query_columns< ::MHJDeviceBase, id_mysql, A >::
  virtualKeyCount (A::table_name, "`virtualKeyCount`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceBase, id_mysql, A >::virtualKeyDefine_type_
  query_columns< ::MHJDeviceBase, id_mysql, A >::
  virtualKeyDefine (A::table_name, "`virtualKeyDefine`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceBase, id_mysql, A >::switchKeyfCount_type_
  query_columns< ::MHJDeviceBase, id_mysql, A >::
  switchKeyfCount (A::table_name, "`switchKeyfCount`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceBase, id_mysql, A >::security_type_
  query_columns< ::MHJDeviceBase, id_mysql, A >::
  security (A::table_name, "`security`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceBase, id_mysql, A >::createDate_type_
  query_columns< ::MHJDeviceBase, id_mysql, A >::
  createDate (A::table_name, "`createDate`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceBase, id_mysql, A >::createUser_type_
  query_columns< ::MHJDeviceBase, id_mysql, A >::
  createUser (A::table_name, "`createUser`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceBase, id_mysql, A >::createVerification_type_
  query_columns< ::MHJDeviceBase, id_mysql, A >::
  createVerification (A::table_name, "`createVerification`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceBase, id_mysql, A >::productionDate_type_
  query_columns< ::MHJDeviceBase, id_mysql, A >::
  productionDate (A::table_name, "`productionDate`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceBase, id_mysql, A >::productionUser_type_
  query_columns< ::MHJDeviceBase, id_mysql, A >::
  productionUser (A::table_name, "`productionUser`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceBase, id_mysql, A >::activationDate_type_
  query_columns< ::MHJDeviceBase, id_mysql, A >::
  activationDate (A::table_name, "`activationDate`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceBase, id_mysql, A >::deviceFlag_type_
  query_columns< ::MHJDeviceBase, id_mysql, A >::
  deviceFlag (A::table_name, "`deviceFlag`", 0);

  template <typename A>
  struct pointer_query_columns< ::MHJDeviceBase, id_mysql, A >:
    query_columns< ::MHJDeviceBase, id_mysql, A >
  {
  };

  template <>
  class access::object_traits_impl< ::MHJDeviceBase, id_mysql >:
    public access::object_traits< ::MHJDeviceBase >
  {
    public:
    struct id_image_type
    {
      unsigned long long id_value;
      my_bool id_null;

      std::size_t version;
    };

    struct image_type
    {
      // id_
      //
      unsigned long long id_value;
      my_bool id_null;

      // deviceID
      //
      int deviceID_value;
      my_bool deviceID_null;

      // idsecurity
      //
      int idsecurity_value;
      my_bool idsecurity_null;

      // deviceType
      //
      int deviceType_value;
      my_bool deviceType_null;

      // virtualKeyCount
      //
      int virtualKeyCount_value;
      my_bool virtualKeyCount_null;

      // virtualKeyDefine
      //
      details::buffer virtualKeyDefine_value;
      unsigned long virtualKeyDefine_size;
      my_bool virtualKeyDefine_null;

      // switchKeyfCount
      //
      int switchKeyfCount_value;
      my_bool switchKeyfCount_null;

      // security
      //
      details::buffer security_value;
      unsigned long security_size;
      my_bool security_null;

      // createDate
      //
      MYSQL_TIME createDate_value;
      my_bool createDate_null;

      // createUser
      //
      details::buffer createUser_value;
      unsigned long createUser_size;
      my_bool createUser_null;

      // createVerification
      //
      signed char createVerification_value;
      my_bool createVerification_null;

      // productionDate
      //
      MYSQL_TIME productionDate_value;
      my_bool productionDate_null;

      // productionUser
      //
      details::buffer productionUser_value;
      unsigned long productionUser_size;
      my_bool productionUser_null;

      // activationDate
      //
      MYSQL_TIME activationDate_value;
      my_bool activationDate_null;

      // deviceFlag
      //
      int deviceFlag_value;
      my_bool deviceFlag_null;

      std::size_t version;
    };

    struct extra_statement_cache_type;

    using object_traits<object_type>::id;

    static id_type
    id (const id_image_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&,
          my_bool*);

    static void
    bind (MYSQL_BIND*,
          image_type&,
          mysql::statement_kind);

    static void
    bind (MYSQL_BIND*, id_image_type&);

    static bool
    init (image_type&,
          const object_type&,
          mysql::statement_kind);

    static void
    init (object_type&,
          const image_type&,
          database*);

    static void
    init (id_image_type&, const id_type&);

    typedef mysql::object_statements<object_type> statements_type;

    typedef mysql::query_base query_base_type;

    static const std::size_t column_count = 15UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const std::size_t separate_load_column_count = 0UL;
    static const std::size_t separate_update_column_count = 0UL;

    static const bool versioned = false;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    public:
    static bool
    find_ (statements_type&,
           const id_type*);

    static void
    load_ (statements_type&,
           object_type&,
           bool reload);
  };

  template <>
  class access::object_traits_impl< ::MHJDeviceBase, id_common >:
    public access::object_traits_impl< ::MHJDeviceBase, id_mysql >
  {
  };

  // MHJDeviceChild
  //
  template <typename A>
  struct query_columns< ::MHJDeviceChild, id_mysql, A >
  {
    // id
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long unsigned int,
        mysql::id_ulonglong >::query_type,
      mysql::id_ulonglong >
    id_type_;

    static const id_type_ id;

    // deviceID
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long int,
        mysql::id_ulonglong >::query_type,
      mysql::id_ulonglong >
    deviceID_type_;

    static const deviceID_type_ deviceID;

    // keyID
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long unsigned int,
        mysql::id_ulonglong >::query_type,
      mysql::id_ulonglong >
    keyID_type_;

    static const keyID_type_ keyID;

    // Name
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    Name_type_;

    static const Name_type_ Name;

    // userID
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        int,
        mysql::id_long >::query_type,
      mysql::id_long >
    userID_type_;

    static const userID_type_ userID;

    // KeyDefine
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        unsigned int,
        mysql::id_ulong >::query_type,
      mysql::id_ulong >
    KeyDefine_type_;

    static const KeyDefine_type_ KeyDefine;

    // state
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        unsigned int,
        mysql::id_ulong >::query_type,
      mysql::id_ulong >
    state_type_;

    static const state_type_ state;

    // defineChangeTime
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::boost::posix_time::ptime,
        mysql::id_datetime >::query_type,
      mysql::id_datetime >
    defineChangeTime_type_;

    static const defineChangeTime_type_ defineChangeTime;

    // ImgIco
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    ImgIco_type_;

    static const ImgIco_type_ ImgIco;
  };

  template <typename A>
  const typename query_columns< ::MHJDeviceChild, id_mysql, A >::id_type_
  query_columns< ::MHJDeviceChild, id_mysql, A >::
  id (A::table_name, "`id`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceChild, id_mysql, A >::deviceID_type_
  query_columns< ::MHJDeviceChild, id_mysql, A >::
  deviceID (A::table_name, "`device`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceChild, id_mysql, A >::keyID_type_
  query_columns< ::MHJDeviceChild, id_mysql, A >::
  keyID (A::table_name, "`keyID`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceChild, id_mysql, A >::Name_type_
  query_columns< ::MHJDeviceChild, id_mysql, A >::
  Name (A::table_name, "`Name`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceChild, id_mysql, A >::userID_type_
  query_columns< ::MHJDeviceChild, id_mysql, A >::
  userID (A::table_name, "`user`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceChild, id_mysql, A >::KeyDefine_type_
  query_columns< ::MHJDeviceChild, id_mysql, A >::
  KeyDefine (A::table_name, "`KeyDefine`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceChild, id_mysql, A >::state_type_
  query_columns< ::MHJDeviceChild, id_mysql, A >::
  state (A::table_name, "`state`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceChild, id_mysql, A >::defineChangeTime_type_
  query_columns< ::MHJDeviceChild, id_mysql, A >::
  defineChangeTime (A::table_name, "`defineChangeTime`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceChild, id_mysql, A >::ImgIco_type_
  query_columns< ::MHJDeviceChild, id_mysql, A >::
  ImgIco (A::table_name, "`ImgIco`", 0);

  template <typename A>
  struct pointer_query_columns< ::MHJDeviceChild, id_mysql, A >:
    query_columns< ::MHJDeviceChild, id_mysql, A >
  {
  };

  template <>
  class access::object_traits_impl< ::MHJDeviceChild, id_mysql >:
    public access::object_traits< ::MHJDeviceChild >
  {
    public:
    struct id_image_type
    {
      unsigned long long id_value;
      my_bool id_null;

      std::size_t version;
    };

    struct image_type
    {
      // id_
      //
      unsigned long long id_value;
      my_bool id_null;

      // deviceID
      //
      unsigned long long deviceID_value;
      my_bool deviceID_null;

      // keyID
      //
      unsigned long long keyID_value;
      my_bool keyID_null;

      // Name
      //
      details::buffer Name_value;
      unsigned long Name_size;
      my_bool Name_null;

      // userID
      //
      int userID_value;
      my_bool userID_null;

      // KeyDefine
      //
      unsigned int KeyDefine_value;
      my_bool KeyDefine_null;

      // state
      //
      unsigned int state_value;
      my_bool state_null;

      // defineChangeTime
      //
      MYSQL_TIME defineChangeTime_value;
      my_bool defineChangeTime_null;

      // ImgIco
      //
      details::buffer ImgIco_value;
      unsigned long ImgIco_size;
      my_bool ImgIco_null;

      std::size_t version;
    };

    struct extra_statement_cache_type;

    using object_traits<object_type>::id;

    static id_type
    id (const id_image_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&,
          my_bool*);

    static void
    bind (MYSQL_BIND*,
          image_type&,
          mysql::statement_kind);

    static void
    bind (MYSQL_BIND*, id_image_type&);

    static bool
    init (image_type&,
          const object_type&,
          mysql::statement_kind);

    static void
    init (object_type&,
          const image_type&,
          database*);

    static void
    init (id_image_type&, const id_type&);

    typedef mysql::object_statements<object_type> statements_type;

    typedef mysql::query_base query_base_type;

    static const std::size_t column_count = 9UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const std::size_t separate_load_column_count = 0UL;
    static const std::size_t separate_update_column_count = 0UL;

    static const bool versioned = false;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    public:
    static bool
    find_ (statements_type&,
           const id_type*);

    static void
    load_ (statements_type&,
           object_type&,
           bool reload);
  };

  template <>
  class access::object_traits_impl< ::MHJDeviceChild, id_common >:
    public access::object_traits_impl< ::MHJDeviceChild, id_mysql >
  {
  };

  // MHJDeviceVirtualDefine
  //
  template <typename A>
  struct query_columns< ::MHJDeviceVirtualDefine, id_mysql, A >
  {
    // id
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long unsigned int,
        mysql::id_ulonglong >::query_type,
      mysql::id_ulonglong >
    id_type_;

    static const id_type_ id;

    // deviceKeyID
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long unsigned int,
        mysql::id_ulonglong >::query_type,
      mysql::id_ulonglong >
    deviceKeyID_type_;

    static const deviceKeyID_type_ deviceKeyID;

    // targetKeyID
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long unsigned int,
        mysql::id_ulonglong >::query_type,
      mysql::id_ulonglong >
    targetKeyID_type_;

    static const targetKeyID_type_ targetKeyID;

    // targetNewState
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        unsigned int,
        mysql::id_ulong >::query_type,
      mysql::id_ulong >
    targetNewState_type_;

    static const targetNewState_type_ targetNewState;

    // defineTime
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::boost::posix_time::ptime,
        mysql::id_datetime >::query_type,
      mysql::id_datetime >
    defineTime_type_;

    static const defineTime_type_ defineTime;
  };

  template <typename A>
  const typename query_columns< ::MHJDeviceVirtualDefine, id_mysql, A >::id_type_
  query_columns< ::MHJDeviceVirtualDefine, id_mysql, A >::
  id (A::table_name, "`id`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceVirtualDefine, id_mysql, A >::deviceKeyID_type_
  query_columns< ::MHJDeviceVirtualDefine, id_mysql, A >::
  deviceKeyID (A::table_name, "`deviceKey`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceVirtualDefine, id_mysql, A >::targetKeyID_type_
  query_columns< ::MHJDeviceVirtualDefine, id_mysql, A >::
  targetKeyID (A::table_name, "`targetKey`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceVirtualDefine, id_mysql, A >::targetNewState_type_
  query_columns< ::MHJDeviceVirtualDefine, id_mysql, A >::
  targetNewState (A::table_name, "`targetNewState`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceVirtualDefine, id_mysql, A >::defineTime_type_
  query_columns< ::MHJDeviceVirtualDefine, id_mysql, A >::
  defineTime (A::table_name, "`defineTime`", 0);

  template <typename A>
  struct pointer_query_columns< ::MHJDeviceVirtualDefine, id_mysql, A >:
    query_columns< ::MHJDeviceVirtualDefine, id_mysql, A >
  {
  };

  template <>
  class access::object_traits_impl< ::MHJDeviceVirtualDefine, id_mysql >:
    public access::object_traits< ::MHJDeviceVirtualDefine >
  {
    public:
    struct id_image_type
    {
      unsigned long long id_value;
      my_bool id_null;

      std::size_t version;
    };

    struct image_type
    {
      // id_
      //
      unsigned long long id_value;
      my_bool id_null;

      // deviceKeyID
      //
      unsigned long long deviceKeyID_value;
      my_bool deviceKeyID_null;

      // targetKeyID
      //
      unsigned long long targetKeyID_value;
      my_bool targetKeyID_null;

      // targetNewState
      //
      unsigned int targetNewState_value;
      my_bool targetNewState_null;

      // defineTime
      //
      MYSQL_TIME defineTime_value;
      my_bool defineTime_null;

      std::size_t version;
    };

    struct extra_statement_cache_type;

    using object_traits<object_type>::id;

    static id_type
    id (const id_image_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&,
          my_bool*);

    static void
    bind (MYSQL_BIND*,
          image_type&,
          mysql::statement_kind);

    static void
    bind (MYSQL_BIND*, id_image_type&);

    static bool
    init (image_type&,
          const object_type&,
          mysql::statement_kind);

    static void
    init (object_type&,
          const image_type&,
          database*);

    static void
    init (id_image_type&, const id_type&);

    typedef mysql::object_statements<object_type> statements_type;

    typedef mysql::query_base query_base_type;

    static const std::size_t column_count = 5UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const std::size_t separate_load_column_count = 0UL;
    static const std::size_t separate_update_column_count = 0UL;

    static const bool versioned = false;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    public:
    static bool
    find_ (statements_type&,
           const id_type*);

    static void
    load_ (statements_type&,
           object_type&,
           bool reload);
  };

  template <>
  class access::object_traits_impl< ::MHJDeviceVirtualDefine, id_common >:
    public access::object_traits_impl< ::MHJDeviceVirtualDefine, id_mysql >
  {
  };

  // MHJDeviceActivation
  //
  template <typename A>
  struct query_columns< ::MHJDeviceActivation, id_mysql, A >
  {
    // id
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long unsigned int,
        mysql::id_ulonglong >::query_type,
      mysql::id_ulonglong >
    id_type_;

    static const id_type_ id;

    // deviceID
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long int,
        mysql::id_ulonglong >::query_type,
      mysql::id_ulonglong >
    deviceID_type_;

    static const deviceID_type_ deviceID;

    // Date
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::boost::posix_time::ptime,
        mysql::id_datetime >::query_type,
      mysql::id_datetime >
    Date_type_;

    static const Date_type_ Date;

    // ip
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    ip_type_;

    static const ip_type_ ip;

    // mac
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    mac_type_;

    static const mac_type_ mac;

    // userID
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        int,
        mysql::id_long >::query_type,
      mysql::id_long >
    userID_type_;

    static const userID_type_ userID;

    // DeviceName
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    DeviceName_type_;

    static const DeviceName_type_ DeviceName;

    // softVer
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    softVer_type_;

    static const softVer_type_ softVer;

    // newSoftUrl
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    newSoftUrl_type_;

    static const newSoftUrl_type_ newSoftUrl;

    // newSoftVer
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::std::string,
        mysql::id_string >::query_type,
      mysql::id_string >
    newSoftVer_type_;

    static const newSoftVer_type_ newSoftVer;
  };

  template <typename A>
  const typename query_columns< ::MHJDeviceActivation, id_mysql, A >::id_type_
  query_columns< ::MHJDeviceActivation, id_mysql, A >::
  id (A::table_name, "`id`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceActivation, id_mysql, A >::deviceID_type_
  query_columns< ::MHJDeviceActivation, id_mysql, A >::
  deviceID (A::table_name, "`device`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceActivation, id_mysql, A >::Date_type_
  query_columns< ::MHJDeviceActivation, id_mysql, A >::
  Date (A::table_name, "`Date`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceActivation, id_mysql, A >::ip_type_
  query_columns< ::MHJDeviceActivation, id_mysql, A >::
  ip (A::table_name, "`ip`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceActivation, id_mysql, A >::mac_type_
  query_columns< ::MHJDeviceActivation, id_mysql, A >::
  mac (A::table_name, "`mac`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceActivation, id_mysql, A >::userID_type_
  query_columns< ::MHJDeviceActivation, id_mysql, A >::
  userID (A::table_name, "`user`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceActivation, id_mysql, A >::DeviceName_type_
  query_columns< ::MHJDeviceActivation, id_mysql, A >::
  DeviceName (A::table_name, "`DeviceName`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceActivation, id_mysql, A >::softVer_type_
  query_columns< ::MHJDeviceActivation, id_mysql, A >::
  softVer (A::table_name, "`softVer`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceActivation, id_mysql, A >::newSoftUrl_type_
  query_columns< ::MHJDeviceActivation, id_mysql, A >::
  newSoftUrl (A::table_name, "`newSoftUrl`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceActivation, id_mysql, A >::newSoftVer_type_
  query_columns< ::MHJDeviceActivation, id_mysql, A >::
  newSoftVer (A::table_name, "`newSoftVer`", 0);

  template <typename A>
  struct pointer_query_columns< ::MHJDeviceActivation, id_mysql, A >:
    query_columns< ::MHJDeviceActivation, id_mysql, A >
  {
  };

  template <>
  class access::object_traits_impl< ::MHJDeviceActivation, id_mysql >:
    public access::object_traits< ::MHJDeviceActivation >
  {
    public:
    struct id_image_type
    {
      unsigned long long id_value;
      my_bool id_null;

      std::size_t version;
    };

    struct image_type
    {
      // id_
      //
      unsigned long long id_value;
      my_bool id_null;

      // deviceID
      //
      unsigned long long deviceID_value;
      my_bool deviceID_null;

      // Date
      //
      MYSQL_TIME Date_value;
      my_bool Date_null;

      // ip
      //
      details::buffer ip_value;
      unsigned long ip_size;
      my_bool ip_null;

      // mac
      //
      details::buffer mac_value;
      unsigned long mac_size;
      my_bool mac_null;

      // userID
      //
      int userID_value;
      my_bool userID_null;

      // DeviceName
      //
      details::buffer DeviceName_value;
      unsigned long DeviceName_size;
      my_bool DeviceName_null;

      // softVer
      //
      details::buffer softVer_value;
      unsigned long softVer_size;
      my_bool softVer_null;

      // newSoftUrl
      //
      details::buffer newSoftUrl_value;
      unsigned long newSoftUrl_size;
      my_bool newSoftUrl_null;

      // newSoftVer
      //
      details::buffer newSoftVer_value;
      unsigned long newSoftVer_size;
      my_bool newSoftVer_null;

      std::size_t version;
    };

    struct extra_statement_cache_type;

    using object_traits<object_type>::id;

    static id_type
    id (const id_image_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&,
          my_bool*);

    static void
    bind (MYSQL_BIND*,
          image_type&,
          mysql::statement_kind);

    static void
    bind (MYSQL_BIND*, id_image_type&);

    static bool
    init (image_type&,
          const object_type&,
          mysql::statement_kind);

    static void
    init (object_type&,
          const image_type&,
          database*);

    static void
    init (id_image_type&, const id_type&);

    typedef mysql::object_statements<object_type> statements_type;

    typedef mysql::query_base query_base_type;

    static const std::size_t column_count = 10UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const std::size_t separate_load_column_count = 0UL;
    static const std::size_t separate_update_column_count = 0UL;

    static const bool versioned = false;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    public:
    static bool
    find_ (statements_type&,
           const id_type*);

    static void
    load_ (statements_type&,
           object_type&,
           bool reload);
  };

  template <>
  class access::object_traits_impl< ::MHJDeviceActivation, id_common >:
    public access::object_traits_impl< ::MHJDeviceActivation, id_mysql >
  {
  };

  // MHJDeviceAuthorize
  //
  template <typename A>
  struct query_columns< ::MHJDeviceAuthorize, id_mysql, A >
  {
    // id
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long unsigned int,
        mysql::id_ulonglong >::query_type,
      mysql::id_ulonglong >
    id_type_;

    static const id_type_ id;

    // deviceID
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long int,
        mysql::id_ulonglong >::query_type,
      mysql::id_ulonglong >
    deviceID_type_;

    static const deviceID_type_ deviceID;

    // childID
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        long int,
        mysql::id_ulonglong >::query_type,
      mysql::id_ulonglong >
    childID_type_;

    static const childID_type_ childID;

    // startDate
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::boost::posix_time::ptime,
        mysql::id_datetime >::query_type,
      mysql::id_datetime >
    startDate_type_;

    static const startDate_type_ startDate;

    // endDate
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        ::boost::posix_time::ptime,
        mysql::id_datetime >::query_type,
      mysql::id_datetime >
    endDate_type_;

    static const endDate_type_ endDate;

    // userID
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        int,
        mysql::id_long >::query_type,
      mysql::id_long >
    userID_type_;

    static const userID_type_ userID;

    // giveUserID
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        int,
        mysql::id_long >::query_type,
      mysql::id_long >
    giveUserID_type_;

    static const giveUserID_type_ giveUserID;

    // giveType
    //
    typedef
    mysql::query_column<
      mysql::value_traits<
        int,
        mysql::id_long >::query_type,
      mysql::id_long >
    giveType_type_;

    static const giveType_type_ giveType;
  };

  template <typename A>
  const typename query_columns< ::MHJDeviceAuthorize, id_mysql, A >::id_type_
  query_columns< ::MHJDeviceAuthorize, id_mysql, A >::
  id (A::table_name, "`id`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceAuthorize, id_mysql, A >::deviceID_type_
  query_columns< ::MHJDeviceAuthorize, id_mysql, A >::
  deviceID (A::table_name, "`device`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceAuthorize, id_mysql, A >::childID_type_
  query_columns< ::MHJDeviceAuthorize, id_mysql, A >::
  childID (A::table_name, "`child`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceAuthorize, id_mysql, A >::startDate_type_
  query_columns< ::MHJDeviceAuthorize, id_mysql, A >::
  startDate (A::table_name, "`startDate`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceAuthorize, id_mysql, A >::endDate_type_
  query_columns< ::MHJDeviceAuthorize, id_mysql, A >::
  endDate (A::table_name, "`endDate`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceAuthorize, id_mysql, A >::userID_type_
  query_columns< ::MHJDeviceAuthorize, id_mysql, A >::
  userID (A::table_name, "`user`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceAuthorize, id_mysql, A >::giveUserID_type_
  query_columns< ::MHJDeviceAuthorize, id_mysql, A >::
  giveUserID (A::table_name, "`giveUser`", 0);

  template <typename A>
  const typename query_columns< ::MHJDeviceAuthorize, id_mysql, A >::giveType_type_
  query_columns< ::MHJDeviceAuthorize, id_mysql, A >::
  giveType (A::table_name, "`giveType`", 0);

  template <typename A>
  struct pointer_query_columns< ::MHJDeviceAuthorize, id_mysql, A >:
    query_columns< ::MHJDeviceAuthorize, id_mysql, A >
  {
  };

  template <>
  class access::object_traits_impl< ::MHJDeviceAuthorize, id_mysql >:
    public access::object_traits< ::MHJDeviceAuthorize >
  {
    public:
    struct id_image_type
    {
      unsigned long long id_value;
      my_bool id_null;

      std::size_t version;
    };

    struct image_type
    {
      // id_
      //
      unsigned long long id_value;
      my_bool id_null;

      // deviceID
      //
      unsigned long long deviceID_value;
      my_bool deviceID_null;

      // childID
      //
      unsigned long long childID_value;
      my_bool childID_null;

      // startDate
      //
      MYSQL_TIME startDate_value;
      my_bool startDate_null;

      // endDate
      //
      MYSQL_TIME endDate_value;
      my_bool endDate_null;

      // userID
      //
      int userID_value;
      my_bool userID_null;

      // giveUserID
      //
      int giveUserID_value;
      my_bool giveUserID_null;

      // giveType
      //
      int giveType_value;
      my_bool giveType_null;

      std::size_t version;
    };

    struct extra_statement_cache_type;

    using object_traits<object_type>::id;

    static id_type
    id (const id_image_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&,
          my_bool*);

    static void
    bind (MYSQL_BIND*,
          image_type&,
          mysql::statement_kind);

    static void
    bind (MYSQL_BIND*, id_image_type&);

    static bool
    init (image_type&,
          const object_type&,
          mysql::statement_kind);

    static void
    init (object_type&,
          const image_type&,
          database*);

    static void
    init (id_image_type&, const id_type&);

    typedef mysql::object_statements<object_type> statements_type;

    typedef mysql::query_base query_base_type;

    static const std::size_t column_count = 8UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const std::size_t separate_load_column_count = 0UL;
    static const std::size_t separate_update_column_count = 0UL;

    static const bool versioned = false;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    public:
    static bool
    find_ (statements_type&,
           const id_type*);

    static void
    load_ (statements_type&,
           object_type&,
           bool reload);
  };

  template <>
  class access::object_traits_impl< ::MHJDeviceAuthorize, id_common >:
    public access::object_traits_impl< ::MHJDeviceAuthorize, id_mysql >
  {
  };

  // MHJUserEntity
  //
  template <>
  class access::view_traits_impl< ::MHJUserEntity, id_mysql >:
    public access::view_traits< ::MHJUserEntity >
  {
    public:
    struct image_type
    {
      // id
      //
      int id_value;
      my_bool id_null;

      // UserName
      //
      details::buffer UserName_value;
      unsigned long UserName_size;
      my_bool UserName_null;

      // UserTitle
      //
      details::buffer UserTitle_value;
      unsigned long UserTitle_size;
      my_bool UserTitle_null;

      // Password
      //
      details::buffer Password_value;
      unsigned long Password_size;
      my_bool Password_null;

      // userToken
      //
      details::buffer userToken_value;
      unsigned long userToken_size;
      my_bool userToken_null;

      // tokenReplaceTime
      //
      long long tokenReplaceTime_value;
      my_bool tokenReplaceTime_null;

      std::size_t version;
    };

    typedef mysql::view_statements<view_type> statements_type;

    typedef mysql::query_base query_base_type;
    struct query_columns
    {
    };

    static const bool versioned = false;

    static bool
    grow (image_type&,
          my_bool*);

    static void
    bind (MYSQL_BIND*,
          image_type&);

    static void
    init (view_type&,
          const image_type&,
          database*);

    static const std::size_t column_count = 6UL;

    static query_base_type
    query_statement (const query_base_type&);

    static result<view_type>
    query (database&, const query_base_type&);
  };

  template <>
  class access::view_traits_impl< ::MHJUserEntity, id_common >:
    public access::view_traits_impl< ::MHJUserEntity, id_mysql >
  {
  };

  // MHJAdminEntity
  //
  template <>
  class access::view_traits_impl< ::MHJAdminEntity, id_mysql >:
    public access::view_traits< ::MHJAdminEntity >
  {
    public:
    struct image_type
    {
      // id
      //
      int id_value;
      my_bool id_null;

      // UserName
      //
      details::buffer UserName_value;
      unsigned long UserName_size;
      my_bool UserName_null;

      // Password
      //
      details::buffer Password_value;
      unsigned long Password_size;
      my_bool Password_null;

      // adminToken
      //
      details::buffer adminToken_value;
      unsigned long adminToken_size;
      my_bool adminToken_null;

      // tokenReplaceTime
      //
      MYSQL_TIME tokenReplaceTime_value;
      my_bool tokenReplaceTime_null;

      std::size_t version;
    };

    typedef mysql::view_statements<view_type> statements_type;

    typedef mysql::query_base query_base_type;
    struct query_columns
    {
    };

    static const bool versioned = false;

    static bool
    grow (image_type&,
          my_bool*);

    static void
    bind (MYSQL_BIND*,
          image_type&);

    static void
    init (view_type&,
          const image_type&,
          database*);

    static const std::size_t column_count = 5UL;

    static query_base_type
    query_statement (const query_base_type&);

    static result<view_type>
    query (database&, const query_base_type&);
  };

  template <>
  class access::view_traits_impl< ::MHJAdminEntity, id_common >:
    public access::view_traits_impl< ::MHJAdminEntity, id_mysql >
  {
  };

  // MHJDeviceBase
  //
  // MHJDeviceChild
  //
  // MHJDeviceVirtualDefine
  //
  // MHJDeviceActivation
  //
  // MHJDeviceAuthorize
  //
}

#include "MHJDatabase-odb.ixx"

#include <odb/post.hxx>
#endif
#endif // MHJDATABASE_ODB_HXX
